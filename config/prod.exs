import Config

# Database credentials come from environment variables so we can deploy the
# same release to different infrastructures without re-compiling. The
# DATABASE_URL is expected to include the username, password, host and
# database name (ecto://USER:PASS@HOST/DATABASE).
database_url =
  System.get_env("DATABASE_URL") ||
    "ecto://postgres:password@pgbouncer:6432/fastcheck_prod"

# Enforce IPv6 sockets only when explicitly requested because some hosts (such
# as containers) only expose IPv4 networking.
maybe_ipv6 = if System.get_env("ECTO_IPV6") in ~w(true 1), do: [:inet6], else: []

config :fastcheck, FastCheck.Repo,
  url: database_url,
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "20"),
  socket_options: maybe_ipv6,
  # Require SSL/TLS at the database level to satisfy production security
  # requirements. You can point DB_SSL_CA at the CA bundle installed on the
  # host (the default matches Debian/Ubuntu) or provide a custom CA chain.
  ssl: true,
  ssl_opts: [
    verify: :verify_peer,
    cacertfile: System.get_env("DB_SSL_CA") || "/etc/ssl/certs/ca-certificates.crt"
  ]

# DOMAIN and PORT are pulled from the environment to make it clear that the app
# is normally fronted by a reverse proxy (Nginx/Caddy) that terminates TLS but
# still needs Phoenix to know about the canonical host.
domain = System.get_env("DOMAIN") || "example.com"
port = String.to_integer(System.get_env("PORT") || "8080")
mobile_app_origin = System.get_env("MOBILE_APP_ORIGIN")
dashboard_origin = "https://#{domain}"

cors_origins =
  [mobile_app_origin, dashboard_origin]
  |> Enum.reject(&is_nil/1)

# Default to Let's Encrypt locations so operators only need to override the
# paths when their certificates live elsewhere.
ssl_cert_env = System.get_env("SSL_CERT_PATH")
ssl_key_env = System.get_env("SSL_KEY_PATH")

ssl_cert_path = ssl_cert_env || "/etc/letsencrypt/live/#{domain}/fullchain.pem"

ssl_key_path = ssl_key_env || "/etc/letsencrypt/live/#{domain}/privkey.pem"

enable_https =
  System.get_env("ENABLE_HTTPS") in ~w(true 1) ||
    (ssl_cert_env && ssl_key_env)

endpoint_config = [
  # Cache manifest generated by `mix assets.deploy`. Phoenix will use this to
  # serve digested asset names.
  cache_static_manifest: "priv/static/cache_manifest.json",
  # Tell Phoenix to advertise the public host and scheme for URL generation.
  url: [host: domain, scheme: "https", port: 443],
  # Force secure cookies and redirect HTTP traffic that arrives from the
  # reverse proxy. `rewrite_on` ensures Phoenix respects X-Forwarded-* headers.
  force_ssl: [hsts: true, rewrite_on: [:x_forwarded_proto]],
  # Lock down websocket/origin checks to the production host.
  check_origin: ["https://#{domain}"],
  cors_origins: cors_origins,
  # Bind to all interfaces. The reverse proxy forwards requests to this port.
  http: [ip: {0, 0, 0, 0, 0, 0, 0, 0}, port: port],
  # Allow per-environment overrides of Plug.Session options. The endpoint
  # merges these values with its defaults so we can mark the cookie secure.
  session_options: [secure: true]
]

endpoint_config =
  if enable_https do
    Keyword.put(endpoint_config, :https,
      port: String.to_integer(System.get_env("HTTPS_PORT") || "443"),
      cipher_suite: :strong,
      certfile: ssl_cert_path,
      keyfile: ssl_key_path
    )
  else
    endpoint_config
  end

config :fastcheck, FastCheckWeb.Endpoint, endpoint_config

# Use the Req-based Swoosh API client and disable the local mailbox cache for
# production deliveries.
config :swoosh, api_client: Swoosh.ApiClient.Req
config :swoosh, local: false

# Only emit :info logs in production to reduce noise.
config :logger, level: :info
