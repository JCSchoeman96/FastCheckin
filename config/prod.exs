import Config

# Database credentials come from environment variables so we can deploy the
# same release to different infrastructures without re-compiling. The
# DATABASE_URL is expected to include the username, password, host and
# database name (ecto://USER:PASS@HOST/DATABASE).
database_url =
  System.get_env("DATABASE_URL") ||
    "ecto://postgres:password@pgbouncer:6432/fastcheck_prod"

# Enforce IPv6 sockets only when explicitly requested because some hosts (such
# as containers) only expose IPv4 networking.
maybe_ipv6 = if System.get_env("ECTO_IPV6") in ~w(true 1), do: [:inet6], else: []

config :fastcheck, FastCheck.Repo,
  url: database_url,
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
  socket_options: maybe_ipv6,
  # Require SSL/TLS at the database level to satisfy production security
  # requirements. You can point DB_SSL_CA at the CA bundle installed on the
  # host (the default matches Debian/Ubuntu) or provide a custom CA chain.
  ssl: true,
  ssl_opts: [
    verify: :verify_peer,
    cacertfile: System.get_env("DB_SSL_CA") || "/etc/ssl/certs/ca-certificates.crt"
  ]

# DOMAIN and PORT are pulled from the environment to make it clear that the app
# is normally fronted by a reverse proxy (Nginx/Caddy) that terminates TLS but
# still needs Phoenix to know about the canonical host.
domain = System.get_env("DOMAIN") || "example.com"
port = String.to_integer(System.get_env("PORT") || "8080")

# Default to Let's Encrypt locations so operators only need to override the
# paths when their certificates live elsewhere.
ssl_cert_path =
  System.get_env("SSL_CERT_PATH") || "/etc/letsencrypt/live/#{domain}/fullchain.pem"

ssl_key_path =
  System.get_env("SSL_KEY_PATH") || "/etc/letsencrypt/live/#{domain}/privkey.pem"

config :fastcheck, FastCheckWeb.Endpoint,
  # Cache manifest generated by `mix assets.deploy`. Phoenix will use this to
  # serve digested asset names.
  cache_static_manifest: "priv/static/cache_manifest.json",
  # Tell Phoenix to advertise the public host and scheme for URL generation.
  url: [host: domain, scheme: "https", port: 443],
  # Force secure cookies and redirect HTTP traffic that arrives from the
  # reverse proxy. `rewrite_on` ensures Phoenix respects X-Forwarded-* headers.
  force_ssl: [hsts: true, rewrite_on: [:x_forwarded_proto]],
  # Lock down websocket/origin checks to the production host.
  check_origin: ["https://#{domain}"],
  # Bind to all interfaces. The reverse proxy forwards requests to this port.
  http: [ip: {0, 0, 0, 0, 0, 0, 0, 0}, port: port],
  # Provide Phoenix with TLS paths when it needs to terminate HTTPS directly
  # (useful for local testing or when no proxy is present).
  https: [
    port: 443,
    cipher_suite: :strong,
    certfile: ssl_cert_path,
    keyfile: ssl_key_path
  ],
  # Allow per-environment overrides of Plug.Session options. The endpoint
  # merges these values with its defaults so we can mark the cookie secure.
  session_options: [secure: true]

# Use the Req-based Swoosh API client and disable the local mailbox cache for
# production deliveries.
config :swoosh, api_client: Swoosh.ApiClient.Req
config :swoosh, local: false

# Only emit :info logs in production to reduce noise.
config :logger, level: :info
